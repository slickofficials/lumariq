package com.lumariq.android.ui

import android.app.Activity
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.util.Base64
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.lumariq.android.BiometricGate
import com.lumariq.android.LedgerBus
import com.lumariq.android.NetworkClient
import com.lumariq.android.SensorySystem
import com.lumariq.android.TransactionDto
import com.lumariq.android.TxSelection
import com.lumariq.android.ui.theme.TerminalGreen
import kotlinx.coroutines.launch
import java.security.KeyPairGenerator
import java.security.KeyStore
import java.security.Signature
import java.time.Instant
private const val KEY_ALIAS = "lumariq_transfer_signing_key"

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AuthorizeScreen(nav: NavController, sensory: SensorySystem) {
    val ctx = LocalContext.current
    val activity = (ctx as Activity)
    val scope = rememberCoroutineScope()

    val prev = nav.previousBackStackEntry
    val h = prev?.savedStateHandle

    val recipient = h?.get<String>("pending_recipient")?.trim().orEmpty()
    val amount = h?.get<Double>("pending_amount") ?: 0.0
    val currency = h?.get<String>("pending_currency") ?: "USD"
    val intentId = h?.get<String>("pending_intentId").orEmpty()
    val challenge = h?.get<String>("pending_challenge").orEmpty()
    val expiresAt = h?.get<String>("pending_expiresAt").orEmpty()

    var busy by remember { mutableStateOf(false) }
    var info by remember { mutableStateOf("Confirm with device lock to sign + dispatch.") }
    var err by remember { mutableStateOf<String?>(null) }

    fun ensureKeyPair(): Pair<ByteArray, java.security.PrivateKey> {
        val ks = KeyStore.getInstance("AndroidKeyStore").apply { load(null) }
        if (!ks.containsAlias(KEY_ALIAS)) {
            val kpg = KeyPairGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_EC,
                "AndroidKeyStore"
            )
            val spec = KeyGenParameterSpec.Builder(
                KEY_ALIAS,
                KeyProperties.PURPOSE_SIGN or KeyProperties.PURPOSE_VERIFY
            )
                .setDigests(KeyProperties.DIGEST_SHA256)
                .setUserAuthenticationRequired(false)
                .build()
            kpg.initialize(spec)
            kpg.generateKeyPair()
        }
        val entry = ks.getEntry(KEY_ALIAS, null) as KeyStore.PrivateKeyEntry
        return entry.certificate.publicKey.encoded to entry.privateKey
    }

    fun signedPayloadBytes(): ByteArray {
        val expMs = runCatching { Instant.parse(expiresAt).toEpochMilli() }.getOrElse { 0L }
        val payload = listOf(intentId, recipient, amount.toString(), currency, challenge, expMs.toString()).joinToString("|")
        return payload.toByteArray(Charsets.UTF_8)
    }

    val launcher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.StartActivityForResult()
    ) { res ->
        if (res.resultCode != Activity.RESULT_OK) {
            err = "Authorization cancelled"
            sensory.feedbackClick()
            busy = false
            return@rememberLauncherForActivityResult
        }

        scope.launch {
            try {
                info = "Signing..."
                val (pubBytes, priv) = ensureKeyPair()
                val sig = Signature.getInstance("SHA256withECDSA")
                sig.initSign(priv)
                sig.update(signedPayloadBytes())
                val signatureBytes = sig.sign()

                val pubB64 = Base64.encodeToString(pubBytes, Base64.NO_WRAP)
                val sigB64 = Base64.encodeToString(signatureBytes, Base64.NO_WRAP)

                info = "Confirming..."
                val resp = NetworkClient.confirmTransfer(intentId, pubB64, sigB64)

                if (resp.status.uppercase() == "CONFIRMED") {
                    sensory.feedbackClick()

                    // âœ… BRIDGE: populate receipt model + refresh ledger
                    val cents = amount * 100.0
                    val tx = TransactionDto(
                        id = resp.txId,
                        counterparty = recipient.ifBlank { "Unknown" },
                        amount = cents.toDouble(),
                        currency = currency,
                        status = "COMPLETED",
                        type = "DEBIT",
                        createdAt = Instant.now().toString(),
                        memo = "Wire Transfer to ${recipient.ifBlank { "Unknown" }}"
                    )
                    TxSelection.selected = tx
                    LedgerBus.bump()

                    nav.popBackStack("transfer", true)
                    nav.navigate("receipt")
                } else {
                    sensory.feedbackClick()
                    err = "Confirm failed: ${resp.message.ifBlank { resp.status }}"
                }
            } catch (e: Exception) {
                sensory.feedbackClick()
                err = "Auth flow error: ${e.message ?: "unknown"}"
            } finally {
                busy = false
            }
        }
    }

    fun startDeviceAuth() {
        err = null
        if (busy) return
        sensory.feedbackClick()

        if (recipient.isBlank() || amount <= 0.0 || intentId.isBlank()) {
            err = "Missing intent. Go back and retry."
            return
        }

        val intent = BiometricGate.createDeviceCredentialIntent(activity)
        if (intent == null) {
            err = "Device lock not set."
            return
        }

        busy = true
        info = "Awaiting device confirmation..."
        launcher.launch(intent)
    }

    Scaffold(
        containerColor = Color.Black,
        topBar = {
            TopAppBar(
                title = { Text(">_ AUTH", color = TerminalGreen, fontWeight = FontWeight.Bold) },
                navigationIcon = {
                    TextButton(onClick = { nav.popBackStack() }) { Text("< BACK", color = TerminalGreen) }
                },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Black)
            )
        }
    ) { pad ->
        Column(
            Modifier.fillMaxSize().padding(pad).padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Card(
                colors = CardDefaults.cardColors(containerColor = Color(0xFF111111)),
                border = BorderStroke(1.dp, Color.DarkGray),
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
                    Text("Recipient: $recipient", color = Color(0xFFBDBDBD))
                    Text("Amount: $amount $currency", color = Color(0xFFBDBDBD))
                    Text(info, color = Color(0xFFBDBDBD))
                }
            }

            err?.let { Text(it, color = Color(0xFFFF6B6B)) }

            Button(
                onClick = { startDeviceAuth() },
                enabled = !busy,
                modifier = Modifier.fillMaxWidth().height(52.dp),
                colors = ButtonDefaults.buttonColors(containerColor = TerminalGreen, contentColor = Color.Black)
            ) {
                Text(if (busy) "AUTHORIZING..." else "CONFIRM (DEVICE LOCK)", fontWeight = FontWeight.Bold)
            }
        }
    }
}
